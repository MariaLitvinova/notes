Один из самых распространённых способов организации взаимодействия - сети контрактов (Contract Net). Его можно рассматривать как разновидность аукциона.

Плюсы:
- открытость
- масштабируемость
- широкая поддержка

Устройство:
- есть 2 роли: заказчик и подрядчик (заказчик, как правило, один, а подрядчиков много; но в реальных задачах подрядчики могут выступать как заказчик)
1. заказчик рассылает запрос (rtf) на задачу ("есть задача, за сколько вы готовы её сделать?")
2. подрядчик делает estimation задачи и отсылает предложение (propose), где указывает цену
3. заказчик делает оценку (evaluate), выбирает самое лучшее предложение
4. заказчик отправляет выбранному подрядчику agree
5. подрядчик отправляет подтверждение (confirm)
6. остальным подрядчикам заказчик отправляет reject
7. через некоторое время подрядчик выполняет задачу и шлёт заказчику подтверждение его выполнения

Разница с аукционами:
- evaluate и estimate может использовать несколько параметров (но чаще всего сводят оценку к одной цифре всё равно)

Свойства:
1. открытый протокол: участники не фиксированы (их выбирают перед шагом 1)
2. масштабируемый протокол: подрядчики могут декомпозировать задачу и договориться с субподрядчиками
3. протокол реализован во многих библиотеках

==================================================

Теоретическая база (формальный анализ протокола)

- T - множество заданий
- A - множество агентов
- task assignment: для каждого А задаём множество задач, которые он исполняет (подмножество Т): c_u
- задания не пересекаются, объединение даёт множество всех задач
(т.е. есть некоторое разбиение задач между агентами)
- функция сложности v: 2^T -> R+ (по множеству задач оценивает сложность)

Задача: найти распределение задач, которое бы минимизировало сумму сложности: arg min sum(v(c_u))

==================================================

Def: маргинальная цена добавления задач - насколько цена вырастет при добавлении задачи
MC_u_add(t) = v(c_u and {t}) - v(c_u)

Def: маргинальная цена удаления задачи
MC_u_del(t) = v(c_u) - v(c_u \ {t})

Возникает ситуация: MC_ui_del(t) > MC_uj_add(t)
Тогда агент i передаёт агенту j задачу вместе с некоторым вознаграждением p (которое находится в интервале MC_ui_del(t); MC_uj_add(t)), тогда обоим агентам выгоден такой обмен

Пример
- два груза G1 и G2, нужно перевезти его в точку F
- один агент находится близко к грузам, а другой далеко
- первому проще довезти грузы до нужной точки, и возникает возможность передачи задач (за определённую стоимость)

Использование:
1. генерируем случайное распределение задач
2. даём агентам искать разные варианты перестановок
3. агенты ищут перестановки, пользуясь представленной эвристикой
4. с каждым заключённым контрактом стоимость уменьшается
(это hill-climbing алгоритм)

Чем больше возможность по перетасовыванию задач, тем ближе они подберутся к минимуму.
Но существует проблема: точки локального минимума (когда в текущей ситуации ничего улучшить нельзя, но на самом деле можно)
Для того, чтобы её решить, появились различные варианты этого контракта.

==================================================

Original contract: описанный выше контракт
Swap-contract: агенты обмениваются задачами
Кластерный контракт: передаётся сразу подмножество задач
Мультиагентный контракт: в цепочке появляется несколько агентов, и каждый передаёт по цепочке; при этом каждый переход в отдельности может не улучшить стоимость, а цепочка продвинет алгоритм дальше

Ни один тип контрактов выкинуть нельзя (можно придумать ситуацию, где мы застрянем в локальном минимуме). Кроме того, все эти типы тоже не гарантируют незастревания.

=> OSCM-контракт
2 матрицы:
- (2^T)^AxA (агент i отдаёт j множество задач, j отдаёт k и т.д.)
- матрица стоимости R^AxA

Плюс:
- позволяет перевести систему за один шаг из любого состояния в любое (не застрянем)
Минус:
- поиск контрактов дорог

Поэтому OSCM почти не используется

==================================================

Откуда вообще возникает локальный минимум? Нет возможности думать о будущем (агент оценивает выгоду только исходя из текущей ситуации), а если бы он мог планировать дальше, он бы увидел более выгодный вариант.

Ещё выход: разные способы расторжения контрактов

1. Условные контракты
В контракт прописываются условия расторжения (если одно из них осуществится, контракт расторгается)
2. Контракты с отступным
Это тоже контракты, которые можно расторгнуть, но им вместо условий приписывается неустойка, которую нужно заплатить в случае разрыва. Они проще в реализации (не нужно сложной коммуникации), но оценка тоже должна являться не с потолка, агент должен проводить некоторое рассуждение. 

Но если дать агентам слишком много возможностей по расторжению, то алгоритм может войти в колебательную фазу, нет гарантий сходимости. Тем не менее, это один из самых распространённых подходов. Кроме того, при накапливании опыта взаимодействий агенты могут учиться и выбирать лучшие варианты. Можно позволить построить не самое оптимальное решение в надежде, что мы сможем дальше отыграть.

==================================================

Торг

Ситуация торга возникает, когда двум агентам надо о чём-то договориться.
Формально:
- 2 агента
- пространство выходов О
- для каждого агента есть функция полезности u1, u2: O -> R+
Задача: договориться до решения О*; если не удаётся договориться, включается вариант Of (fallback), его ценность значительно меньше, чем у компромисса.

Пример: разбиение доллара/100 рублей
Вы с другом идёте по дороге и находите 100 рублей
- если вы договоритесь, каждый заберёт свою часть
- иначе вы не получите ничего
Выгоднее поделить, но каждый будет настаивать на своём

==================================================

Подходы: аксиоматический подход (набор свойств, которым должно обладать решение, затем подбираем результат)

Аксиомы Нэша
1. симметричность (должны получить то же решение, если поменяем агентов местами)
2. независимость от иррелевантных альтернатив (при добавлении О`, которое не является предпочтительным, решение не изменится)
3. эффективность по Парето (нельзя найти решение, в котором оба агента получили бы больше)

В задаче разбиения доллара:
- ищем O* = arg max (u1(O) - u1(Of)) * (u2(O) - u2(Of))
В таком варианте решение будет поделить доллар пополам.

Но не всегда поиск максимума можно реализовать (оценка каждого варианты может быть достаточно дорогой, и посчитать все варианты не представляется возможным)

==================================================

Подходы: стратегический торг

- один агент делает предложение
- второй либо соглашается, либо делает контр-предложение

Нюансы: 
1. если мы позволим торгу идти бесконечно, то агенты не договорятся никогда
Для ограничения можно применять:
- ограничение по времени (неинтересный вариант, т.к. тот, у кого будет право предложения на последнем коне, выиграет)
- стоимость раунда (за переход в следующий раунд агенты должны платить; но тоже не очень хорошо: если c1 = c2, то решения они не находят, т.е. могут прийти к любому решению, а если c1 < c2, то первый агент получает всё - в результате торга он может увести второго в минус, и второй, понимая это, не будет участвовать в игре; если c2 < c1, то чуть интереснее, но мы на втором шаге попадаем в предыдущую ситуацию, тогда первый агент должен в первом раунде предложить то, что он и так бы получил)
/*замечание: вообще, если мы вводим некоторое ограничение, агенты приходят к тому, что договариваются сразу*/
- дисконтирование (здесь мы домножаем на дисконт-фактор агентов, стоимость постепенно снижается; но здесь возникают некоторые интересные решения)

Пример (для дисконтирования)
(про то, что мы раскручиваем с конца)
- игра находится в моменте t
- первый агент ходит, предлагая второму агенту некоторую цену

I - что получает I
II - что получает II

момент	I		II	ход
	1-(1-б1*х)*б2
			1-б1p1	2
t	pi			1

x = 1 - (1 - б1 * х) * б2
х = (1 - б2) / (1 - б1 * б2) - то, что оставляет себе первый агент

У первого агента есть преимущество, и чем больше цена раунда, тем выше преимущество. 

==================================================

На практике, как правило, при торге есть несколько параметров, и предложение агента - это конкретный набор. Агент может согласиться или не согласиться и выдвинуть свой набор. Поэтому выдвижение лучшего решения не всегда возможно (агенты не знают о структуре функции полезности).

Если игра длится долго, агент может начать строить модель оппонента и исходя из неё выдвигать предложения.

Агентов в торгах может быть больше двух, они хорошо масштабируются. Тогда агенты делают предложения по очереди. Но, как правило, торги применяются в небольшом кругу достаточно сложных агентов. В торгах выбор достаточно сложен, и на практике торги распространены реже аукционов/выборов/contract net-ов

==================================================

В домашке:
1. Для расписания
Каждое расписание представляем агентом
Агенты договариваются друг с другом об обмене
(но это притянуто за уши)
2. В задачах про дороги лучше зайдут contract net/аукционы/выборы