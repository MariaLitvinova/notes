Средства разработки мультиагентных систем

MACE - первая система; там были заложены все основные блоки, которые можно найти у современных сред:
1. Рантайм: средства времени выполнения, обеспечивающие решение задач асинхронной коммуникации, управления потоками, работы с сетью
2. Системные агенты: решают ряд инфраструктурных задач (реестры, где могут регистрироваться агенты; запуск и создание агентов через специального агента)
3. Прикладные агенты (разрабатываются с нуля)
3. Инструменты отладки + развёртывание, мониторинг: позволяют понять, что происходит внутри системы

==================================================

Парадигмы разработки МАС

1. Разработка нового языка (новый язык программирования, ориентированный на агенты; в нём определены абстракции "агент", "сообщение")
+ получаем сродство с нашей областью
- можем потерять в гибкости (некоторые вещи, которые можно просто выразить на обычном языке, здесь будут сложновыразимы)
- нужно готовить новых специалистов
2. Интегрированные среды (IDE): агентов нужно не писать, а рисовать
+ в картинках просто изобразить простые вещи
- сложные вещи не получается изобразить вообще
Не используется сейчас, но есть системы симуляции, в которых логика агента может быть нарисована.
3. Расширения существующих языков (дополнение существующего языка новыми возможностями)
Можно добавлять:
- новые конструкции (берём Java, добавляем ключевое слово Agent): проект JACK (но он столкнулся с тем, что сразу отваливается рефакторинг, подсветка синтаксиса)
- стыкуем несколько языков (3APL - agent programming language): логику агентов описываем на Prolog, у агента есть база знаний, инструкции, как строить планы; внутри шаги плана были реализованы на более низкоуровневом язык
- библиотека классов (есть ООП-язык со своим комьюнити, мы в этот язык добавляем дополнительные классы, позволяющие упростить разработку): JADE - Java Agent development; Akka

==================================================

JADE

Библиотека классов, расширяющая Java; в основном добавляет вещи, связанные с асинхронной коммуникацией.
Основные понятия:
- платформа (запускается, слушается на одном порту, другие могут к ней подключаться; некоторый физический процесс)
- контейнер (логическое пространство внутри платформы, где содержатся агенты; может быть несколько)
- агент
Специальные агенты:
- AMS: agent management system (отвечает за функционирование платформы)
- PF (жёлтые страницы, где устанавливается сообщение между агентами)

Может быть несколько хостов, на них платформы, они могут коммуницировать.
Для агентов всё прозрачно: указывается адрес name@host:port (name - имя агента, host - хост, port - порт); агенту без разницы, общаться с локальным или с удалённым агентом; при обращении к сервису "жёлтые страницы" агент получит адреса не только локальных агентов, но вообще всех.

В чём выражается ориентированность JADE на асинхронную коммуникацию?
Есть понятие Behaviour, и агент может реализовывать несколько поведений: несколько поведений организуются в цикл, и агент идёт по этому циклу. Например, в рамках одного поведения есть диалог, мы отправляем сообщение и переходим к следующему поведению; идём по циклу, доходим до этого поведения, теперь надо получить сообщение, и мы проверяем, если есть сообщение в очереди, то получаем и выполняем действие, а если его нет, то поведение может заблокироваться (т.е. поведение заканчивает свой шаг и передаёт дальше, а само на некоторое время выключается из цикла: до момента, пока не истечёт время/не будет получено хотя бы одно новое сообщение), затем оно снова добавляется в цикл и проверяет, истекло ли время или было получено сообщение (если время истекло, нужно запустить некоторый альтернативный сценарий). Т.е. поведение - не монолит. 

Роль - аналог интерфейса в ООП, здесь роль тесно связана с поведением; может быть реализована в виде поведения и переиспользована в разных агентах. Т.е. плюс разбиения поведений на блоки - эффективный механизм переиспользования логики.

С множественным наследованием проблем нет (используется инкапсуляция вместо наследования, агент может реализовывать несколько поведений).

==================================================

Базовые блоки поведений в JADE

1. OneShot - основной строительный блок в поведении, шаг
2. Cyclic - циклическое поведение, антагонист OneShot; каждый раз делаем одно и то же. Пример: агент должен принимать сообщение и что-то с ним дальше делать (запускать новое поведение). Используется для ответно-реагирующего поведения.
3. Sequence - последовательность шагов, где шаг - это поведение.
4. Parallel - антагонист Sequence; тоже формируется из последовательности шагов, но в Sequence пока один шаг не закончится, на следующий не перейдём; в параллельном поведении это что-то вроде цикла (как только мы должны сделать шаг, мы предлагаем его совершить, но не ждём, пока шаг закончится)
У Parallel может быть несколько вариантов выхода:
- когда все вложенные поведения завершатся
- когда хотя бы одно завершится
Sequence нужен в подавляющем большинстве сценариев. Иногда возникают внештатные ситуации (пришло недостаточное число ответов, чёткая последовательность нарушается), тогда может сделать Sequence reset, и оно начнётся с первого шага. В большинстве сценариев первый шаг - поиск партнёров, т.е. мы начинаем с чистого листа.
5. FSM (finite state machine, конечный автомат)
Несколько состояний, с каждым связано некоторое поведение; между состояниями возможны переходы. Код возврата поведения интерпретируется как условие перехода.

==================================================

Поведение Reciever, методы коммуникации

1. Send (принимает message, который нужно отправить)
2. Recieve (принимает message template - описание, какое сообщение нам сейчас нужно: перформатив, conversationID, replyTo,...) - иначе поведения могут начать красть сообщения друг у друга; нужно, чтобы не было конфликтов
Метод получения сообщения неблокирующий.
3. Block - исключает поведение из ротации, пока не будет получено новое сообщение; он тоже неблокирующий

Типичные ошибки:
- некорректные message template 
- некорректное использование block (иногда сообщение в очереди есть, но поведение его не видит: дело в том, что при block мы запоминаем состояние пула сообщений и текущее время, и если block вызвать в неурочное время (без вызова recieve или если recieve вернул не null), то можно получить некорректное поведение)

Напрямую recieve и block имеет смысл использовать в cyclic поведении:
- получаем сообщение : msg = recieve(tmp)
- проверяем: если msg != null, то делаем что-то, иначе блокируем
Иначе имеет смысл использовать Reciever behaviour (установить ещё и время, которое мы готовы ждать).

Могут быть сложности с мультипликативностью - собираем несколько ответов. Тогда можно использовать параллельное поведение.

==================================================

Ещё поведения:

1. Ticker (что-то, что делается по таймеру на регулярной основе)
2. Waker (одноразовый ticker, сработает один раз и больше работать не будет) - можно использовать для добавления ожидания в разного рода симуляциях или как дополнительный шаг при рестарте: если произошёл отказ, не надо прямо сейчас перезапускаться, нужно немного подождать
3. Protocols (реализация комплексных поведений)
Например, contract net. Реализует поиск подрядчиков, сборку предложений, контроль таймаутов. Нам нужно определить логику оценки предложений, длину таймаута и другие параметры.

==================================================

Про сообщения

У сообщения есть атрибут Content и несколько стратегий, как к нему подходить:
1. если сообщения просты, то это могут быть флаги
2. xml/json сериализация: объект сериализуем в json, пересылаем, на другой стороне десериализуем
3. бинарная сериализация (лучше не надо: в JADE есть средства отладки, и в бинарном формате мы теряем возможность посмотреть, что происходит)
4. Ontology - некоторый способ текстовой сериализации более высокого уровня: есть такой-то концепт, у него такие-то атрибуты, таким-то образом они должны сериализоваться

==================================================

Про запуск и отладку

Главный класс - Boot. В качестве аргументов ему можно передать, каких агентов можно запустить. Если их много, делается агент-инициализатор, создающий остальных. 
Можно использовать опцию -gui, тогда стартует агент RMA (можно посмотреть, какие контейнеры есть, выполнить базовые процедуры отладки, развёртывания и т.д.; первые запуски можно делать через него). Можно подключиться к удалённой системе.
Через RMA имеется доступ к функциям отладки
- sniffer - агент, который может быть запущен через rma и может послушивать агентов (какие сообщения они отправляют)
- DA - можно самому прикинуться агентом и посылать сообщения
- introspector - позволяет заглянуть внутрь агента и посмотреть, какие поведения у него активны, какие сообщения у него висят в очереди и т.д.

==================================================

Про взаимодействие с пользовательским интерфейсом и многопоточность

Каждый агент работает в одном потоке, не выполняя несколько поведений параллельно. Реализуется вытесняющая многозадачность.
Про синхронизацию потоков следует задумываться, когда мы взаимодействуем с UI - у него свой поток, и это не тот поток, в котором работают агенты. 
Если мы хотим из UI что-то передать агенту, нужно добавить ему дополнительное поведение. 

==================================================

Установить JADE, запустить, посмотреть.
Примеры:
- behaviours
- Yellow pages
- создание других агентов