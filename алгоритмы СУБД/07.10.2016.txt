Восстановление после отказов

"Всё не работает" делится на три категории:
1. Отказы отдельных транзакций (что делать, если транзакция обрывается?)
Это зависит от того, как реализована система
2. Отказы системы (независимо от того, по каким причинам; ситуация, когда сервер не в состоянии выполнять никакие операции или запросы, и для восстановления его работоспособности требуется перезапуск, но предполагается, что данные на диске не испорчены; они, однако же, могут быть несогласованы)
3. Отказы носителя (когда данные не могут быть прочитаны с постоянного носителя, тогда система тоже не может выполнять никакие запросы и транзакции, и рестартом уже не обойтись)

==============================================================

Самый простой -- это отказ отдельной транзакции
Приём, который здесь используется -- обратная операция записи (операция, записывающая состояние, которое было перед выполнением данной операции, поэтому операция обратной записи, выполненная сразу после обрыва, восстанавливает состояние; операции нужно выполнять в обратном порядке; это называется откатом, rollback)

Добавим в расписание обратные операции.
Выясняется, что расписания, которые мы считали правильными, оказываются несериализуемыми по конфликтам. Вся теория разваливается. Нужно сделать что-то, чтобы её починить. 
Сделаем несколько неправильных попыток.

1. Редуцируемость -- используем коммутативность, чтобы убрать из расписания операции, относящиеся к оборванным транзакциям. Этот критерий плохо работает -- некоторые редуцируемые расписания имеют префикс, оказавшийся нередуцируемым, а класс расписаний долже быть префиксно замкнут

2. Префиксная редуцируемость -- когда можно свести не только расписание, но и его префикс. Это уже почти хороший критерий, но всё равно всё плохо, потому что сериализуемые расписания не обязательно префиксно-редуцируемы. Нет вложения ни в одну сторону.

У нас ничего с критериями не вышло, будем смотреть на свойства расписаний, которые могут быть полезны.

1. Расписание восстановимо <=> его можно восстановить
Расписание невосстановимо: первая транзакция записала, вторая записала и зафиксировалась, пытаемся откатить первую, и ничего не можем сделать.
Подзадержим вторую транзакцию, пока не выяснится судьба первой. Если первая зафиксируется, то выполним вторую. Если первая обрывается, вынуждены оборвать вторую (это каскадный обрыв). Это плохая ситуация: мы уничтожаем результаты работы других транзакций.

2. Можем попытаться обойтись без этого. Свойство -- бескаскадность.
Гарантирует, что при обрывах транзакций не понадобится каскадно обрывать другие транзакции. Оно несколько ограничивает класс расписаний, уменьшает степень параллелизма, но меньше ресурсов тратится на оборваные транзакции.

3. Точность.
Все операции записи второй транзакции, если она пытается записать то, что выполняла первая, придерживаются до фиксации первой транзакции.

4. Строгость (регрессность)
Любые конфликтующие операции второй транзакции задерживаются до фиксации/обрыва первой транзакции. Класс очень узкий (таких расписаний очень мало).

Далее -- то, ради чего всё делалось.

Префиксная редуцируемость <=> восстановимость по журналу + сериализуемость.

==============================================================

Как надо изменить протоколы, чтобы гарантировать восстановимость?

Почему двухфазный протокол блокирования оказывается очень ограничительным?
Нужно удерживать замки до конца транзакций, и класс расписаний получается очень узким.

Можно расширять протокол на основе графа сериализуемости, можно расширять протокол на основе меток времени.

Определяем расширенную коммутативность:
- операции коммутируют
- их обратные коммутируют

==============================================================

Восстановление после отказов

Система по любым причинам пришла в состояние, когда она не может выполнять запросы.
Могли быть незавершённые активные транзакции.
Система работает в оперативной памяти => возможно, какие-то завершённые транзакции не записались.

Части системы:
- БД на диске
- образ некоторой части БД в кэше
- журнал
- часть журнала в ОП

Можем выполнять некоторые операции:
- чтение
- запись
- сброс в БД из кэша
- считывание в кэш

На самом деле БД -- совокупность всех операций, включённых в расписание, а кэш -- некоторое подмножество операций, при это если операция содержится в кэше, в БД она тоже содержится. Если операция находится на диске, то все более ранние тоже там. То же самое с журналом (его стабильной частью). Журнал -- некоторая часть истории, в стабильной части всегда префикс. Для БД это необязательно префикс (1 элемент модифицировали и записали, а второй модифицировали и не записали).

Чтобы это было наукой, определим "корректное восстановление" -- после рестарта системы приводит систему в состояние, когда все завершённые транзакции записаны, а все незавершённые (активные) не оставят никакого следа.

Основное правило: если выполняется некоторая операция, прежде чем она попадёт в БД, она должна быть записана в журнал. В журнал всё пишется "с опережением".

Журная можно записывать по-разному. Иногда потребуется повторять, и в журнале может быть запись "redo/undo".

Стратегии ведения журнала:
- ничего не записывать до фиксации
- не фиксировать транзакцию, пока все её операции не будут записаны
обе эти стратегии приводят к большим задержками =>
- комбинированная стратегия

Ещё одна интересная стратегия: не имеем права записывать что-то до фиксации и не имеем права фиксировать ничего, пока транзакция не записана (фиксация = одно атомарное действие). Как это сделать? Записываем копии, изменяем "каталог", а затем в одну запись меняем ссылку на оглавление. Этот метод использовался в ранних версиях Oracle, он хорош для оптимистических протоколов.

==============================================================

Алгоритмы восстановления

У нас есть журнал, и мы хотим восстановить состояние. 

...

