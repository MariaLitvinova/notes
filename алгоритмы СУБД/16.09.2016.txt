Мы увидели, что VSR слишком трудоёмок
Ищем другие критерии эквивалентности

Для этого введём понятие конфликта
Конфликт -- упорядоченная пара операций, работающая с одними данными, принадлежащая разным транзакциям, одна из них должна быть операцией записи
В любом сколько-нибудь интересном расписании есть конфликт (нулевая записывает все данные, и любая другая назодится с ней в конфликте)

Определим также эквивалентность по конфликтам -- когда множество конфликтов совпадает
Таким образом, если первая читает, а вторая пишет, а в другом расписании вторая сначала пишет, а потом первая читает, то они НЕ эквивалетны

Сериализуемость по конфликтам влечёт за собой сериализуемость по видимому состоянию:
- для каждой операции чтения предыдущая операция записи должна быть той же самой
- представим, что у нас есть операция чтения, предшествующая операции записи в одном расписании, и то же в другом расписании
- если предыдущая операция записи будет другая, то конфликты будут обязательно различаться
- значит, отношение  "читает из" будет одинаково
- значит, расписание, сериализуемое по конфликтом является сериализуемым по VSR

Также можно придумать VSR, не совпадающее по конфликтам (поменять в расписании w1w2...первые операции записи местами)

Определим граф сериализуемости (для определения сериализуемости) -- на самом деле ориентированный мультиграф
Множество вершин -- множество транзакций
Две вершины соединены, если в транзакциях есть конфликт (для каждого конфликта проводим дугу из первой транзакции конфликта во вторую)
Тогда критерий сериализуемости звучит так: транзакции сериализуемы по конфликтам <=> в графе нет контуров

Докажем его:
<= 
нет контуров, значит, можем построить топологическую сортировку графа: найдём транзакцию, из которой не выходят дуги, исключим её, в новом графе тем более не будет контуров. так образом, вытягиваем транзакции по одной.
=>
в серийном расписании не может быть контуров (иначе стрелка должна пройти назад, и более поздняя операция предшествует более ранней, чего не может быть)

Также введём ещё один критерий.
Можем вместо конфликтов говорить о коммутативности операций
Операции коммутируют, если от их перестановки расписание остаётся эквивалентным (например, операции над разными элементами, ещё операции чтения; уже упорядоченные в рамках транзакции операции не коммутируют)
Операции коммутируют <=> они не находятся в конфликте.
От их перестановки граф сериализуемости не меняется, и расписание остаётся сериализуемым по конфликтам, если оно таковым являлось.
Нам надо, чтобы расписание было частично упорядоченным (мы всегда сможем перейти к полной упорядоченности)
Если при помощи перестановки соседних коммутирующих операций мы можем превратить расписание к серийному, то исходное называется сериализуемым по коммутативности.
Зачем? когда говорим о коммутативности, нам всё равно, какова семантика операций. Если мы выяснили в некоторой системе операций, что они коммутативны, то мы можем доказать сериализуемость, несмотря на то, что семантика их скрыта от нас.

Сериализуемость по конфликтам имеет некоторые парадоксальные свойства:
- транзакции (на слайде 21) сериализуются в порядке, противоположном тому, как они выполнялись, и это единственный способ их сериализовать. То есть отношение предшествования в расписании -- не то же самое, что и упорядоченность по времени
Можем определить класс расписаний, сериализуемых по конфликтам, и где запрещены такие перестановки (в некоторых случаях нам может понадобиться именно такой класс)

Есть более узкое: транзакции фиксировались в некотором порядке, и COCSR требует, чтобы они были сериализуемы по конфликтам и в том же порядке, в котором они были вначале.

Также нужно принять меры, чтобы оборванные транзакции как-то обрабатывались (мы постулировали, что они обрабатываются правильно, но это на самом деле не так).
Для этого рассмотрим префиксную замкнутость: префикс каждого расписания классу принадлежит классу (для частичной упорядоченности: операция и всё, что ей предшествует).
Расписание -- префикс истории
т.е. "расписание обладает свойством Х => любой его префикс обладает этим свойством"
- класс расписаний, сериализуемых по конечным состояниям, не замкнут (конечное состояние будет другим); а нас интересует только последняя операция
- а вот класс расписаний, сериализуемых по видимому состоянию, замкнут (семантики Эрбрана зависят только от предшествующих => если всё совпадало для расписания, то для префикса тоже всё будет совпадать). Это свойство даёт возможность исключать оборванные транзакции

На самом деле эти критерии используются не совсем так, как предполагает теория.

==============================================================================

Дальше будем заниматься протоколами, обеспечивающими корректность.