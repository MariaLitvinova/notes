Мы увидели, что VSR слишком трудоёмок
Ищем другие критерии эквивалентности

Для этого введём понятие конфликта
Конфликт -- упорядоченная пара операций, работающая с одними данными, принадлежащая разным транзакциям, одна из них должна быть операцией записи
В любом сколько-нибудь интересном расписании есть конфликт (нулевая записывает все данные, и любая другая назодится с ней в конфликте)

Определим также эквивалентность по конфликтам -- когда множество конфликтов совпадает
Таким образом, если первая читает, а вторая пишет, а в другом расписании вторая сначала пишет, а потом первая читает, то они НЕ эквивалетны

Сериализуемость по конфликтам влечёт за собой сериализуемость по видимому состоянию:
- для каждой операции чтения предыдущая операция записи должна быть той же самой
- представим, что у нас есть операция чтения, предшествующая операции записи в одном расписании, и то же в другом расписании
- если предыдущая операция записи будет другая, то конфликты будут обязательно различаться
- значит, отношение  "читает из" будет одинаково
- значит, расписание, сериализуемое по конфликтом является сериализуемым по VSR

Также можно придумать VSR, не совпадающее по конфликтам (поменять в расписании w1w2...первые операции записи местами)

Определим граф сериализуемости (для определения сериализуемости) -- на самом деле ориентированный мультиграф
Множество вершин -- множество транзакций
Две вершины соединены, если в транзакциях есть конфликт (для каждого конфликта проводим дугу из первой транзакции конфликта во вторую)
Тогда критерий сериализуемости звучит так: транзакции сериализуемы по конфликтам <=> в графе нет контуров

Докажем его:
<= 
нет контуров, значит, можем построить топологическую сортировку графа: найдём транзакцию, из которой не выходят дуги, исключим её, в новом графе тем более не будет контуров. так образом, вытягиваем транзакции по одной.
=>
в серийном расписании не может быть контуров (иначе стрелка должна пройти назад, и более поздняя операция предшествует более ранней, чего не может быть)

Также введём ещё один критерий.
Можем вместо конфликтов говорить о коммутативности операций
Операции коммутируют, если от их перестановки расписание остаётся эквивалентным (например, операции над разными элементами, ещё операции чтения; уже упорядоченные в рамках транзакции операции не коммутируют)
Операции коммутируют <=> они не находятся в конфликте.
От их перестановки граф сериализуемости не меняется, и расписание остаётся сериализуемым по конфликтам, если оно таковым являлось.
Нам надо, чтобы расписание было частично упорядоченным (мы всегда сможем перейти к полной упорядоченности)
Если при помощи перестановки соседних коммутирующих операций мы можем превратить расписание к серийному, то исходное называется сериализуемым по коммутативности.
Зачем? когда говорим о коммутативности, нам всё равно, какова семантика операций. Если мы выяснили в некоторой системе операций, что они коммутативны, то мы можем доказать сериализуемость, несмотря на то, что семантика их скрыта от нас.

Сериализуемость по конфликтам имеет некоторые парадоксальные свойства:
- транзакции (на слайде 21) сериализуются в порядке, противоположном тому, как они выполнялись, и это единственный способ их сериализовать. То есть отношение предшествования в расписании -- не то же самое, что и упорядоченность по времени
Можем определить класс расписаний, сериализуемых по конфликтам, и где запрещены такие перестановки (в некоторых случаях нам может понадобиться именно такой класс)

Есть более узкое: транзакции фиксировались в некотором порядке, и COCSR требует, чтобы они были сериализуемы по конфликтам и в том же порядке, в котором они были вначале.

Также нужно принять меры, чтобы оборванные транзакции как-то обрабатывались (мы постулировали, что они обрабатываются правильно, но это на самом деле не так).
Для этого рассмотрим префиксную замкнутость: префикс каждого расписания классу принадлежит классу (для частичной упорядоченности: операция и всё, что ей предшествует).
Расписание -- префикс истории
т.е. "расписание обладает свойством Х => любой его префикс обладает этим свойством"
- класс расписаний, сериализуемых по конечным состояниям, не замкнут (конечное состояние будет другим); а нас интересует только последняя операция
- а вот класс расписаний, сериализуемых по видимому состоянию, замкнут (семантики Эрбрана зависят только от предшествующих => если всё совпадало для расписания, то для префикса тоже всё будет совпадать). Это свойство даёт возможность исключать оборванные транзакции

На самом деле эти критерии используются не совсем так, как предполагает теория.

==============================================================================

Дальше будем заниматься протоколами, обеспечивающими корректность.

Сначала уточним, как устроен сервер.
1. Менеджер транзакций регистрирует транзакции, присваивает им идентификаторы и разбирается с клиентом, если с транзакцией что-то произошло.
Номер транзакции он посылает диспетчеру.
2. Диспетчер делает всю работу
Он получает поток операций, и его задача --- сделать так, чтобы они выполнялись в сериализуемом порядке. Он сортирует операции так, чтобы стало "лучше"
3. Выполняет операции некоторый обработчик данных, у которого есть некоторое представление о том, как это делать.
Диспечер транзакций понимает, что переставлять некоторые операции нельзя -- от этого расписание может стать несериализуемым.
Все эти системы по-разному понимают эффективность и корректность.

Функционирование диспетчера
К нему приходит очередная операция, и он может поступить следующими способами:
1. отправить на выполнение (самое лучшее -- не помешает параллелизму)
2. если он знает, что сейчас нельзя выполнять операцию, то он может её придержать до выполнения условий, и когда они будут выполнены, запустить её
3. он может сказать, что эту транзакуию уже никак не встроить в сериализуемое расписание
Он может быть:
1. пессимистическим -- если неприятность может случиться, она случится
2. оптимистическим -- неприятности случаются редко, и надо попытаться выполнить операцию,  если что-то пойдёт не так, то и ладно
Также может быть:
1. консервативным -- предотвращает неприятные ситуации
2. ?? -- устраняет последствия
От диспетчера хотелось бы получить максимальную пропускную способность (чтобы механизм диспетчирования не приводил к обрывам и избыточному ожиданию)
Пример очень консервативного и очень пессимистичного диспетчера:
- первую операцию отправляет на выполнение
- остальные операции из друих транзакций выстраивает в очередь, и они ждут, пока им разрешат выполниться
- как только пришло подтверждение выполнения, выбирает самую старую операцию и даёт ей выполниться
Таким образом степень параллелизма будет назкой, а время ожидания -- долгим.

Поэтому нужны другие механизмы планирования.
Планировщики в централизованных системах основаны на понятии замка (lock)
Замки могут устанавливаться на некоторые ресурсы.
Впрочем, чтобы устанавливать замок, не нужен даже ресурс (например, установка замка на предикат --- у нас в модели нет такого, но там, где можно использовать предикаты, можно установить такой замок, и все данные, удовлетворяющие предикату, оказываются под его действиям).
Замок устанавливается для некоторой операции, если есть конфликт.
- если замки конфликтуют, и установка замка невозможна, то транзакция, для которой хотим установить замок, ставится на ожидание
- замок должен быть снят до окончания

Замечание:
- семафоры-мьютексы-и т.д. ставятся на участки программы
- замки ставятся на данные (являются более высокоуровневым механизмом). Факт установки замка не предотвращает выполнение операции для других данных.
Сами по себе замки никак сериализуемость не обеспечивают.

==============================================================================

Двухфазный протокол

Каждая транзакция имеет право устанавливать замки в любом порядке на любые элементы данных, но после того, как один из замков был снят, установка замков становится невозможной.
Фаза 1: установление
Фаза 2: снятие
Транзакция может снимать замки, как только данные стали ей не нужны.

Нужно доказать корректность протокола.
Для этого нужно доказать отсутствие контуров в груфе сериализуемости.
Для этого предствим, что имеется цепочка конфликтов: 1 в конфликте со 2 (по элементу данных х), 2 в конфликте с 3 (по элементу данных у). Надо доказать, что операция над у следует за операцией над х (т.е. направление стрелок не зависит от того, какие данные участвуют в конфликте). Если получится контур, то замок последней транзакции нужно установить позже, чем он был снят, а этого быть не может.
Транзакция 3 не может установить замок на у до того, как 2 сняла его. 