В прошлый раз было анонсировано управление на основе множественных версий. Идея в том, чтобы дать отставшим транзакциям возможность завершиться, если есть возможность сериализовать их.

Для того, чтобы сделать это точно, пересмотрим понятие расписания. Раньше оно показывало, как соотносятся разные операции, а сейчас нужно ещё учесть, что для всех элементов может быть несколько версий. Как их различать? Нужно каждую версию идентифицировать номером той транзакции, которая её записала. Читающая транзакция всегда читает какую-нибудь версии => индекс всегда будет отличаться. При этом нельзя прочитать ерсию, которая ещё не была записана => операция чтения всегда следует за той операцией, которая записала. Теперь версия играет такую же роль, как элемент данных в обычном расписании.

Есть важный класс мультиверсионных расписаний -- монорасписания. Они эквивалентны какому-нибудь обычному расписанию с одной версией. 

Далее пытаемся определить критерий эквивалентности. Сериализуемость по видимому состоянию оказывается слишком слабой => нужно что-то более сильное.
Для того, чтобы говорить о мультиверсионной сериализуемости, нужно ввести новый критерий. Вводим MV-сериализуемость.

С конфликтами произойдёт то же самое (разные операции записи не находятся в конфликте, они пишут разные версии, конфликтов слишком мало). Мы не можем построить контроль согласованности на основе только конфликтов. 
Просто коммутативности нам тоже мало. Чтобы сделать что-то разумное, мы вводим упорядоченность версий одного элемента и вводим в граф сериализуемости дуги, связанные с упорядочением версий. Тогда получаются упорядоченные транзакции, которые его писали. Нужно, чтобы упорядочивание было одним и тем же. Если нет контуров, тогда расписание сериализуемо в смысле множественных версий.

Можно ограничить количество возможных версий и рассматривать классы транзакций, тогда можно увидеть, что эти классы вкладываются друг в друга. 

=========================================================================

Мультиверсионный протокол с метками времени.
В многоверсионном варианте мы всегда можем найти последний элемент данных, записанный раньше, чем транзакция попыталась его прочитать, возможно, есть ещё версии, но мы всегда можем найти правильную версию (самую молодую). Таким образом, любая операция чтения будет выполнена -- никаких ограничений на чтение нет.
На запись есть -- новое значение можно записать, только если никакая другая транзакция с более поздней меткой времени не читала его (находим самое позднее чтение, запись искать не обязательно). Если это условие нарушено, запись будет отменена.
Протокол хорошо работает и в распределённом случае (метки времени проверять можно локально -- назначаются они глобально, и об этом нужно позаботиться, а вот проверка может быть локальной).
Можно строить протокол на основе замков. Наиболее частый случай -- двухверсионный (обычный двухфазный, но у каждого элемента может быть 2 версии -- текущая и та, на которую установлен замок). Упорядоченная операция записи делается за счёт установки замков.
Можно строить многоверсионный граф сериализуемости с дополнительными дугами. Этот протокол имеет только теоретическое значение (никто его не использует в практике), поэтому рассматривать его не будем.
Читающие транзакции всегда могут быть обслужены.

=========================================================================

Объектная модель

Модель достаточно примитивна, но здесь видно, как можно повысить степень параллелизма при выполнении транзакций.

Объекты представлены набором операций, операция может вызывать другие операции. Расписание -- некоторый лес, а транзакция -- дерево (динамическое дерево вызовов -- операции вызывают следующие объекты). Операции высокого уровня коммутируют => их можно переставлять, даже если низкоуровневые операции находятся в конфликте. 

Определим серийное расписание -- деревья друг от друга изолированы, одно за другим.
Расслоённое расписание -- все листья находятся на одинаковом расстоянии от корня; про каждую операцию известно, на каком уровне она находится.

На слайде "примеры корректных расписаний" -- одно честно расслоенное, другое с нарушением.

Введём понятие плоской транзакции ("нижние кустики изолированы"). Плоские расписания могут быть сериализованы с использованием коммутативности.

Введём редукцию (стоящие рядом на одном уровне коммутирующие операции можно переставить, при условии, что деревья, растущие из них, уже разделены -- идём с нижнего уровня, если листья перепутаны, распутываем, есл они коммутируют, и переходим на уровень выше).

На слайде "пример корректного расписания" нижний уровень несериализуем, а верхний коммутирует, и хочется получить корректное расписание.
Ограничимся расслоенными расписаниями. Забываем про нижние и верхние слои, занимаемся упорядочением только текущего слоя -- это называется "расписание на одном слое".

Как рассыпать расписание на два слоя (верхний и нижний)?
На слайде "пример послойных расписаний" в нижнем расписании транзакции гораздо короче, чем на верхнем.

Центральное место этого раздела -- достаточное условие для того, чтобы расслоенное расписание было сериализуемым.
Объектное расслоенное расписание сериализуемо <=> на каждом слое расписание сериализуемо с сохранением порядка транзакций.
Доказательство: с помощью редукции. Сначала распутываем нижний уровень. Поскольку оно сериализуемо, распутываем на основе коммутативности, стягиваем в точку, при этом важно, что операции предыдущего уровня мы не переставляли. После этого распутываем следующий уровень.

Если отказаться от условия сохранения порядка, всё перестанет работать (слайд "нередуцируемое послойно расписание").

На слайде "редуцируемое CSR, но не OCSR" показано, что условие является достаточным, но не необходимым.

Можно пытаться определить коммутативность операций -- если две операции стоят рядом, то для любого префикса и любого суффикса их выполнение в другом порядке даёт тот же ответ. Другие условия (без условия на префикс) не работают.
На основе всего этого можно строить протоколы на основе замков. Можно построить двухфазный протокол (устанавливаем замок на операцию на уровне, и если замок снимается, то с нижнего уровня тоже снимаются замки).

Замечание:
На самом деле, история развивалась наоборот. Модель объектных транзакций появилась в начале 90х и была обобщением многих механизмов. Мы не хотим устанавливать замок на всю страницу (это ограничивает параллелизм).  
На время всей транзакции замки устанавливаются на небольшие объёмы, а при модификации устанавливается задвижка. После модификации задвижка снимается. Это не нарушает сериализуемость больших транзакций и не может быть ситуаций, приводящих к возникновению тупиков.
Это оказалось частным случаем двухуровневой транзакции.

Другой пример (небольшое обобщение того же самого).
Когда мы говорим о реляционных таблицах, можно говорить об индексах (модификация строки -- это модификация строки и индекса, на самом деле; здесь может получиться более двух уровней).

Гибридные алгоритмы
На разных уровнях можно использовать разные протоколы (на нижнем, например, задвижки, а на верхнем -- timestamp).
На эту тему можно писать магистерскую :) строить более высокоуровневые протоколы, более высокоуровневые транзакции, обладающие некоторыми полезными свойствами и снимающие ограничения, которые накладывает транзакционная память.

=========================================================================

Ещё одна тема, немного боковая - конкурентное выполнение.
Что не работает? В реляционной системе мы сформулировали запрос -- строки, удовлетворяющие некоторому условию. Мы не можем установить замки, пока не начали читать, и это беда.
Формулировка в терминах аномалий -- одна транзакция подсунула другой строку, удовлетворяющую условию, а потом она исчезла.

Решение -- предикатные замки. Нам не нужно иметь именно данные для установления замка, можно и на нечто абстрактное установить замок. Теперь мы, например, навесили предикат на условие WHERE. Но нам нужно узнать (для двух предикатов), совместимы ли замки -- конъюнкция на любом наборе данных на любой БД возвращает пустое множество. В общем случае (для предикатов общего вида) задача неразрешима. Поэтому предикатные замки работают только для некоторых случаев.

Можно построить некоторое решение -- определить почти реляционные операции обновления, определить для них коммутативность, строить сериализуемость по коммутативности. Можно эту коммутативность трансформировать в конфликты и устанавливать замки и блокировки.

=========================================================================

Конкурентное использование индексных структур

Для работы с индексами нужно две операции:
1. спуск вниз -- поиск на точечные значения
2. движение вправо -- поиск на >=
Используется для этого B-дерево.

Решение -- устанавливать замки на текущий элемент вплоть до него, но не включая его (от ключа до следующего (???)). Мешает удалить текущую запись и вставить запись между текущим и следующим. 
Далее доказываем корректность (на основе теоремы о достаточном условии).

=========================================================================

В связи с реализацией нужно рассмотреть ещё некоторые вещи.

Мультигранулярность. БД состоит из гранул (вся БД -- гранула, меньшие гранулы -- таблицы). Проблема, которая решается -- простые БД устанавливают замки на таблицу, но для больших БД это не годится (не будет параллелизма). С другой стороны, если устанавливать замки на строки, то нужна куча памяти на замки.
Как замки на строки соотносятся с замками на таблицы? Введём новый вид замков -- intention lock -- утверждение о намерениях. Прежде чем получить замок на модификацию/доступ, мы должны получить intention lock на гранулу (на БД -> на таблицу -> обычный замок на нужные строки).
На слайде "множественная гранулярность замков" показана совместимость замков.

Уровни изоляции SQL -- вынесем на вторую часть курса (о том, как соотносится практика с теорией изоляции).